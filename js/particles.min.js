const canvas = document.querySelector("canvas"),
  ctx = canvas.getContext("2d"),
  effect = document.querySelector(".effect-partciples"),
  canvasHandler = document.querySelector(".photo");
(canvas.width = canvasHandler.offsetWidth),
  (canvas.height = canvasHandler.offsetHeight);
let prevMouse = { x: effect.offsetWidth / 2, y: effect.offsetHeight / 2 };
const particles = [];
class Particle {
  constructor(f, a, b, c, d) {
    (this.x = f),
      (this.y = a),
      (this.velocity = b),
      (this.radius = c),
      (this.color = d);
  }
  draw() {
    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, !1),
      (ctx.fillStyle = this.color),
      ctx.fill(),
      ctx.closePath();
  }
  update() {
    (this.x += this.velocity.x), (this.y += this.velocity.y);
  }
}
function outOfBounds(b) {
  return (
    b.x > canvas.width + b.radius ||
    b.x < -b.radius ||
    b.y > canvas.height + b.radius ||
    b.y < -b.radius
  );
}
function calcNumber() {
  switch (!0) {
    case 576 > window.innerWidth:
      return 25;
    case 768 > window.innerWidth:
      return 50;
    case 992 > window.innerWidth:
      return 60;
    default:
      return 90;
  }
}
let settings = {
  particles: {
    draw: !0,
    number: calcNumber(),
    size: 4,
    speed: 0.7,
    color: "rgba(255,255,255,0.4)",
    effects: { followMouse: { active: !0, followBy: 0.12 } },
  },
  line: { draw: !0, size: 1, radius: 100, color: "rgba(255,255,255,0.4)" },
};
/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  navigator.userAgent
) && (settings.particles.effects.followMouse.active = !1),
  window.addEventListener("resize", () => {
    (canvas.width = canvasHandler.offsetWidth),
      (canvas.height = canvasHandler.offsetHeight),
      (settings.particles.number = calcNumber()),
      particles.length > settings.particles.number
        ? particles.splice(
            settings.particles.number,
            particles.length - settings.particles.number
          )
        : particles.length < settings.particles.number &&
          addParticles(settings.particles.number - particles.length);
  });
function addParticles(c) {
  for (var a = 0; a < c; a++) {
    let d = Math.random() * canvas.width,
      a = Math.random() * canvas.height;
    const b = {
      x: (2 * Math.random() - 1) * settings.particles.speed,
      y: (2 * Math.random() - 1) * settings.particles.speed,
    };
    particles.push(
      new Particle(d, a, b, settings.particles.size, settings.particles.color)
    );
  }
}
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let d = 0; d < particles.length; d++)
    if (
      (particles[d].update(),
      particles[d].draw(),
      outOfBounds(particles[d]) && (particles.splice(d, 1), addParticles(1)),
      (particles[d].x > canvas.width || 0 > particles[d].x) &&
        (particles[d].velocity.x = -particles[d].velocity.x),
      (particles[d].y > canvas.height || 0 > particles[d].y) &&
        (particles[d].velocity.y = -particles[d].velocity.y),
      settings.line.draw)
    )
      for (let a, b = d; b < particles.length; b++)
        (a = Math.hypot(
          particles[d].x - particles[b].x,
          particles[d].y - particles[b].y
        )),
          a - particles[d].radius - particles[b].radius <
            settings.line.radius &&
            ((ctx.strokeStyle = settings.line.color),
            (ctx.lineWidth = settings.line.size),
            ctx.beginPath(),
            ctx.moveTo(particles[d].x, particles[d].y),
            ctx.lineTo(particles[b].x, particles[b].y),
            ctx.stroke(),
            ctx.closePath());
  requestAnimationFrame(animate);
}
window.addEventListener("mousemove", (d) => {
  settings.particles.effects.followMouse.active &&
    setTimeout(() => {
      moving = !0;
      let e = d.clientX - prevMouse.x,
        b = d.clientY - prevMouse.y;
      particles.forEach((c) => {
        (c.x += e * settings.particles.effects.followMouse.followBy),
          (c.y += b * settings.particles.effects.followMouse.followBy);
      }),
        (prevMouse = { x: d.clientX, y: d.clientY });
    }, 100);
}),
  addParticles(settings.particles.number),
  animate();
